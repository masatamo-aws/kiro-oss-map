# 🏗️ Kiro OSS Map v2.1.0 アーキテクチャ設計書

**バージョン**: v2.1.0 - マイクロサービス化・CI/CD統合  
**作成日**: 2025年8月19日  
**アーキテクチャ**: Cloud Native・マイクロサービス  
**品質目標**: Cloud Native Ready ☁️

---

## 🎯 アーキテクチャ概要

### 🌟 設計原則

#### Cloud Native 原則
- **コンテナ化**: すべてのサービスをコンテナで実行
- **動的オーケストレーション**: Kubernetesによる自動管理
- **マイクロサービス**: 疎結合・独立デプロイ可能
- **宣言的API**: Infrastructure as Code
- **観測可能性**: メトリクス・ログ・トレーシング

#### 12-Factor App 準拠
1. **コードベース**: 単一リポジトリ・複数デプロイ
2. **依存関係**: 明示的宣言・分離
3. **設定**: 環境変数による外部化
4. **バッキングサービス**: アタッチされたリソース
5. **ビルド・リリース・実行**: 厳密な分離
6. **プロセス**: ステートレス・シェアードナッシング
7. **ポートバインディング**: サービスをポートで公開
8. **並行性**: プロセスモデルによるスケールアウト
9. **廃棄容易性**: 高速起動・グレースフルシャットダウン
10. **開発・本番一致**: 環境間の差異最小化
11. **ログ**: イベントストリームとして扱う
12. **管理プロセス**: ワンオフプロセスとして実行

---

## 🏗️ システムアーキテクチャ

### 🌐 全体アーキテクチャ図

```mermaid
graph TB
    %% External
    User[👤 User] --> LB[🔄 Load Balancer]
    Dev[👨‍💻 Developer] --> CICD[🚀 CI/CD Pipeline]
    
    %% Load Balancer & API Gateway
    LB --> APIGW[🚪 API Gateway]
    
    %% Frontend
    APIGW --> FE[🖥️ Frontend App]
    
    %% Microservices
    APIGW --> AUTH[🔐 Auth Service]
    APIGW --> MAP[🗺️ Map Service]
    APIGW --> SEARCH[🔍 Search Service]
    APIGW --> ROUTE[🛣️ Route Service]
    APIGW --> USER[👤 User Service]
    
    %% Databases
    AUTH --> AUTHDB[(🗄️ Auth DB)]
    USER --> USERDB[(🗄️ User DB)]
    SEARCH --> SEARCHDB[(🔍 Search DB)]
    
    %% Cache & Message Queue
    AUTH --> REDIS[(📦 Redis Cache)]
    MAP --> REDIS
    SEARCH --> REDIS
    ROUTE --> REDIS
    USER --> REDIS
    
    ROUTE --> QUEUE[📨 Message Queue]
    
    %% External Services
    MAP --> TILES[🗺️ Tile Server]
    SEARCH --> NOMINATIM[🌍 Nominatim API]
    ROUTE --> OSRM[🛣️ OSRM API]
    
    %% Monitoring & Logging
    AUTH --> METRICS[📊 Prometheus]
    MAP --> METRICS
    SEARCH --> METRICS
    ROUTE --> METRICS
    USER --> METRICS
    
    AUTH --> LOGS[📝 Fluentd]
    MAP --> LOGS
    SEARCH --> LOGS
    ROUTE --> LOGS
    USER --> LOGS
    
    METRICS --> GRAFANA[📈 Grafana]
    LOGS --> ELK[🔍 ELK Stack]
    
    %% Tracing
    AUTH --> JAEGER[🔍 Jaeger]
    MAP --> JAEGER
    SEARCH --> JAEGER
    ROUTE --> JAEGER
    USER --> JAEGER
    
    %% CI/CD
    CICD --> K8S[☸️ Kubernetes]
    K8S --> AUTH
    K8S --> MAP
    K8S --> SEARCH
    K8S --> ROUTE
    K8S --> USER
```

### 🔄 データフロー図

```mermaid
sequenceDiagram
    participant U as User
    participant FE as Frontend
    participant GW as API Gateway
    participant AUTH as Auth Service
    participant MAP as Map Service
    participant SEARCH as Search Service
    participant ROUTE as Route Service
    participant USER as User Service
    participant CACHE as Redis Cache
    participant DB as Database
    
    %% Authentication Flow
    U->>FE: Login Request
    FE->>GW: POST /auth/login
    GW->>AUTH: Forward Request
    AUTH->>DB: Validate Credentials
    DB-->>AUTH: User Data
    AUTH->>CACHE: Store Session
    AUTH-->>GW: JWT Token
    GW-->>FE: Authentication Response
    FE-->>U: Login Success
    
    %% Map Display Flow
    U->>FE: Load Map
    FE->>GW: GET /maps/tiles/{z}/{x}/{y}
    GW->>MAP: Forward Request
    MAP->>CACHE: Check Cache
    alt Cache Hit
        CACHE-->>MAP: Cached Tile
    else Cache Miss
        MAP->>External: Fetch Tile
        External-->>MAP: Tile Data
        MAP->>CACHE: Store Cache
    end
    MAP-->>GW: Tile Response
    GW-->>FE: Tile Data
    FE-->>U: Display Map
    
    %% Search Flow
    U->>FE: Search Location
    FE->>GW: GET /search/geocode?q=location
    GW->>SEARCH: Forward Request
    SEARCH->>CACHE: Check Cache
    alt Cache Hit
        CACHE-->>SEARCH: Cached Results
    else Cache Miss
        SEARCH->>External: Nominatim API
        External-->>SEARCH: Search Results
        SEARCH->>CACHE: Store Cache
    end
    SEARCH-->>GW: Search Response
    GW-->>FE: Search Results
    FE-->>U: Display Results
    
    %% Route Calculation Flow
    U->>FE: Calculate Route
    FE->>GW: POST /routes/calculate
    GW->>ROUTE: Forward Request
    ROUTE->>CACHE: Check Cache
    alt Cache Hit
        CACHE-->>ROUTE: Cached Route
    else Cache Miss
        ROUTE->>External: OSRM API
        External-->>ROUTE: Route Data
        ROUTE->>CACHE: Store Cache
    end
    ROUTE-->>GW: Route Response
    GW-->>FE: Route Data
    FE-->>U: Display Route
    
    %% Bookmark Management Flow
    U->>FE: Save Bookmark
    FE->>GW: POST /users/bookmarks
    GW->>USER: Forward Request
    USER->>DB: Store Bookmark
    DB-->>USER: Success
    USER->>CACHE: Update Cache
    USER-->>GW: Success Response
    GW-->>FE: Bookmark Saved
    FE-->>U: Success Message
```

---

## 🔧 マイクロサービス詳細設計

### 🔐 認証サービス (Auth Service)

#### 責任・機能
- **ユーザー認証**: ログイン・ログアウト・セッション管理
- **ユーザー認可**: ロールベースアクセス制御 (RBAC)
- **トークン管理**: JWT発行・検証・リフレッシュ
- **パスワード管理**: ハッシュ化・リセット・変更
- **OAuth2.0/OIDC**: 外部プロバイダー連携

#### API設計
```yaml
openapi: 3.0.0
info:
  title: Auth Service API
  version: 2.1.0
paths:
  /auth/register:
    post:
      summary: ユーザー登録
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                email:
                  type: string
                  format: email
                password:
                  type: string
                  minLength: 8
                name:
                  type: string
      responses:
        '201':
          description: 登録成功
        '400':
          description: バリデーションエラー
        '409':
          description: ユーザー既存
  
  /auth/login:
    post:
      summary: ログイン
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                email:
                  type: string
                  format: email
                password:
                  type: string
      responses:
        '200':
          description: ログイン成功
          content:
            application/json:
              schema:
                type: object
                properties:
                  accessToken:
                    type: string
                  refreshToken:
                    type: string
                  expiresIn:
                    type: integer
        '401':
          description: 認証失敗
  
  /auth/refresh:
    post:
      summary: トークンリフレッシュ
      security:
        - bearerAuth: []
      responses:
        '200':
          description: リフレッシュ成功
        '401':
          description: 無効なトークン
  
  /auth/logout:
    post:
      summary: ログアウト
      security:
        - bearerAuth: []
      responses:
        '200':
          description: ログアウト成功
```

#### データモデル
```typescript
// User Entity
interface User {
  id: string;
  email: string;
  passwordHash: string;
  name: string;
  role: UserRole;
  isActive: boolean;
  emailVerified: boolean;
  createdAt: Date;
  updatedAt: Date;
  lastLoginAt?: Date;
}

enum UserRole {
  USER = 'user',
  ADMIN = 'admin',
  MODERATOR = 'moderator'
}

// Session Entity
interface Session {
  id: string;
  userId: string;
  accessToken: string;
  refreshToken: string;
  expiresAt: Date;
  createdAt: Date;
  ipAddress: string;
  userAgent: string;
}
```

#### 技術スタック
- **Runtime**: Node.js 20 + TypeScript 5
- **Framework**: Express.js + Helmet + CORS
- **Database**: PostgreSQL 15 (ユーザー情報)
- **Cache**: Redis 7 (セッション・トークン)
- **Security**: bcrypt + jsonwebtoken + passport
- **Validation**: Joi + express-validator
- **ORM**: Prisma 5

### 🗺️ 地図サービス (Map Service)

#### 責任・機能
- **タイル配信**: 地図タイルの高速配信
- **スタイル管理**: 地図スタイルの管理・配信
- **キャッシュ管理**: タイル・スタイルのキャッシュ戦略
- **CDN統合**: コンテンツ配信ネットワーク連携
- **カスタムスタイル**: ユーザー定義スタイル対応

#### API設計
```yaml
paths:
  /maps/tiles/{z}/{x}/{y}:
    get:
      summary: 地図タイル取得
      parameters:
        - name: z
          in: path
          required: true
          schema:
            type: integer
            minimum: 0
            maximum: 18
        - name: x
          in: path
          required: true
          schema:
            type: integer
        - name: y
          in: path
          required: true
          schema:
            type: integer
        - name: style
          in: query
          schema:
            type: string
            enum: [standard, satellite, terrain, dark]
      responses:
        '200':
          description: タイル画像
          content:
            image/png:
              schema:
                type: string
                format: binary
        '404':
          description: タイル未発見
  
  /maps/styles:
    get:
      summary: 地図スタイル一覧
      responses:
        '200':
          description: スタイル一覧
          content:
            application/json:
              schema:
                type: array
                items:
                  type: object
                  properties:
                    id:
                      type: string
                    name:
                      type: string
                    description:
                      type: string
                    thumbnail:
                      type: string
                      format: uri
  
  /maps/styles/{styleId}:
    get:
      summary: 地図スタイル取得
      parameters:
        - name: styleId
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: スタイル定義
          content:
            application/json:
              schema:
                type: object
```

#### キャッシュ戦略
```typescript
// タイルキャッシュ戦略
interface TileCacheStrategy {
  // L1: メモリキャッシュ (最頻繁アクセス)
  memoryCache: {
    maxSize: '512MB';
    ttl: '1hour';
    algorithm: 'LRU';
  };
  
  // L2: Redisキャッシュ (高頻度アクセス)
  redisCache: {
    maxSize: '2GB';
    ttl: '24hours';
    keyPattern: 'tile:{style}:{z}:{x}:{y}';
  };
  
  // L3: CDNキャッシュ (グローバル配信)
  cdnCache: {
    ttl: '7days';
    edgeLocations: 'global';
    compressionEnabled: true;
  };
}
```

#### 技術スタック
- **Runtime**: Node.js 20 + TypeScript 5
- **Framework**: Express.js + Sharp (画像処理)
- **Tile Server**: TileServer GL + MapProxy
- **Cache**: Redis + CDN (CloudFlare/AWS CloudFront)
- **Storage**: S3 Compatible (MinIO/AWS S3)
- **Image Processing**: Sharp + ImageMagick

### 🔍 検索サービス (Search Service)

#### 責任・機能
- **ジオコーディング**: 住所→座標変換
- **逆ジオコーディング**: 座標→住所変換
- **POI検索**: 興味地点検索・フィルタリング
- **オートコンプリート**: リアルタイム検索候補
- **検索分析**: 検索パターン・統計分析

#### API設計
```yaml
paths:
  /search/geocode:
    get:
      summary: ジオコーディング
      parameters:
        - name: q
          in: query
          required: true
          schema:
            type: string
            minLength: 2
        - name: limit
          in: query
          schema:
            type: integer
            minimum: 1
            maximum: 50
            default: 10
        - name: countrycode
          in: query
          schema:
            type: string
            pattern: '^[a-z]{2}$'
        - name: bounded
          in: query
          schema:
            type: boolean
        - name: viewbox
          in: query
          schema:
            type: string
            pattern: '^-?\d+\.?\d*,-?\d+\.?\d*,-?\d+\.?\d*,-?\d+\.?\d*$'
      responses:
        '200':
          description: 検索結果
          content:
            application/json:
              schema:
                type: object
                properties:
                  results:
                    type: array
                    items:
                      type: object
                      properties:
                        place_id:
                          type: string
                        display_name:
                          type: string
                        lat:
                          type: number
                        lon:
                          type: number
                        boundingbox:
                          type: array
                          items:
                            type: number
                        class:
                          type: string
                        type:
                          type: string
                        importance:
                          type: number
  
  /search/reverse:
    get:
      summary: 逆ジオコーディング
      parameters:
        - name: lat
          in: query
          required: true
          schema:
            type: number
            minimum: -90
            maximum: 90
        - name: lon
          in: query
          required: true
          schema:
            type: number
            minimum: -180
            maximum: 180
        - name: zoom
          in: query
          schema:
            type: integer
            minimum: 0
            maximum: 18
            default: 18
      responses:
        '200':
          description: 逆ジオコーディング結果
  
  /search/autocomplete:
    get:
      summary: オートコンプリート
      parameters:
        - name: q
          in: query
          required: true
          schema:
            type: string
            minLength: 1
        - name: limit
          in: query
          schema:
            type: integer
            minimum: 1
            maximum: 20
            default: 5
      responses:
        '200':
          description: 候補一覧
```

#### 検索インデックス設計
```json
{
  "mappings": {
    "properties": {
      "place_id": { "type": "keyword" },
      "display_name": { 
        "type": "text",
        "analyzer": "standard",
        "fields": {
          "suggest": {
            "type": "completion",
            "analyzer": "simple"
          }
        }
      },
      "location": { "type": "geo_point" },
      "boundingbox": { "type": "geo_shape" },
      "class": { "type": "keyword" },
      "type": { "type": "keyword" },
      "importance": { "type": "float" },
      "country_code": { "type": "keyword" },
      "admin_levels": {
        "type": "nested",
        "properties": {
          "level": { "type": "integer" },
          "name": { "type": "text" }
        }
      }
    }
  }
}
```

#### 技術スタック
- **Runtime**: Node.js 20 + TypeScript 5
- **Framework**: Express.js + Joi
- **Search Engine**: Elasticsearch 8 + OpenSearch
- **External API**: Nominatim + Overpass API
- **Cache**: Redis (検索結果・候補)
- **Queue**: Bull (重い検索処理)

### 🛣️ ルーティングサービス (Route Service)

#### 責任・機能
- **経路計算**: 最短・最速ルート計算
- **交通手段対応**: 車・徒歩・自転車・公共交通
- **リアルタイム交通**: 交通情報・渋滞考慮
- **経路最適化**: 複数地点最適化
- **ナビゲーション**: ターンバイターン案内

#### API設計
```yaml
paths:
  /routes/calculate:
    post:
      summary: 経路計算
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                coordinates:
                  type: array
                  items:
                    type: array
                    items:
                      type: number
                  minItems: 2
                profile:
                  type: string
                  enum: [driving, walking, cycling, public-transport]
                alternatives:
                  type: boolean
                  default: false
                steps:
                  type: boolean
                  default: true
                geometries:
                  type: string
                  enum: [geojson, polyline, polyline6]
                  default: geojson
                overview:
                  type: string
                  enum: [full, simplified, false]
                  default: simplified
      responses:
        '200':
          description: 経路計算結果
          content:
            application/json:
              schema:
                type: object
                properties:
                  code:
                    type: string
                  routes:
                    type: array
                    items:
                      type: object
                      properties:
                        geometry:
                          type: object
                        legs:
                          type: array
                        distance:
                          type: number
                        duration:
                          type: number
                        steps:
                          type: array
  
  /routes/optimize:
    post:
      summary: 経路最適化 (TSP)
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                coordinates:
                  type: array
                  items:
                    type: array
                    items:
                      type: number
                  minItems: 3
                profile:
                  type: string
                  enum: [driving, walking, cycling]
                source:
                  type: string
                  enum: [first, any]
                  default: first
                destination:
                  type: string
                  enum: [last, any]
                  default: last
      responses:
        '200':
          description: 最適化された経路
```

#### ルーティングエンジン統合
```typescript
// ルーティングエンジン抽象化
interface RoutingEngine {
  calculateRoute(request: RouteRequest): Promise<RouteResponse>;
  calculateMatrix(request: MatrixRequest): Promise<MatrixResponse>;
  optimizeRoute(request: OptimizeRequest): Promise<OptimizeResponse>;
}

// OSRM実装
class OSRMEngine implements RoutingEngine {
  private baseUrl: string;
  
  async calculateRoute(request: RouteRequest): Promise<RouteResponse> {
    const url = `${this.baseUrl}/route/v1/${request.profile}/${request.coordinates.join(';')}`;
    const params = new URLSearchParams({
      alternatives: request.alternatives.toString(),
      steps: request.steps.toString(),
      geometries: request.geometries,
      overview: request.overview
    });
    
    const response = await fetch(`${url}?${params}`);
    return response.json();
  }
}

// GraphHopper実装
class GraphHopperEngine implements RoutingEngine {
  // GraphHopper API実装
}

// ルーティングサービス
class RouteService {
  private engines: Map<string, RoutingEngine>;
  
  constructor() {
    this.engines = new Map([
      ['osrm', new OSRMEngine()],
      ['graphhopper', new GraphHopperEngine()]
    ]);
  }
  
  async calculateRoute(request: RouteRequest): Promise<RouteResponse> {
    const engine = this.engines.get(request.engine || 'osrm');
    return engine.calculateRoute(request);
  }
}
```

#### 技術スタック
- **Runtime**: Node.js 20 + TypeScript 5
- **Framework**: Express.js + Turf.js
- **Routing Engine**: OSRM + GraphHopper
- **Cache**: Redis (経路・交通情報)
- **Queue**: Bull (重い計算処理)
- **Geospatial**: PostGIS (道路ネットワーク)

### 👤 ユーザーサービス (User Service)

#### 責任・機能
- **ブックマーク管理**: 地点保存・編集・削除・カテゴリ管理
- **設定管理**: ユーザー設定・プリファレンス
- **履歴管理**: 検索・ルート履歴
- **データ同期**: デバイス間データ同期
- **プライバシー**: データ暗号化・削除権

#### API設計
```yaml
paths:
  /users/bookmarks:
    get:
      summary: ブックマーク一覧取得
      security:
        - bearerAuth: []
      parameters:
        - name: category
          in: query
          schema:
            type: string
        - name: limit
          in: query
          schema:
            type: integer
            minimum: 1
            maximum: 100
            default: 20
        - name: offset
          in: query
          schema:
            type: integer
            minimum: 0
            default: 0
      responses:
        '200':
          description: ブックマーク一覧
    
    post:
      summary: ブックマーク作成
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                name:
                  type: string
                  maxLength: 100
                description:
                  type: string
                  maxLength: 500
                latitude:
                  type: number
                  minimum: -90
                  maximum: 90
                longitude:
                  type: number
                  minimum: -180
                  maximum: 180
                category:
                  type: string
                  maxLength: 50
                tags:
                  type: array
                  items:
                    type: string
                  maxItems: 10
      responses:
        '201':
          description: ブックマーク作成成功
  
  /users/bookmarks/{bookmarkId}:
    get:
      summary: ブックマーク詳細取得
      security:
        - bearerAuth: []
    
    put:
      summary: ブックマーク更新
      security:
        - bearerAuth: []
    
    delete:
      summary: ブックマーク削除
      security:
        - bearerAuth: []
  
  /users/settings:
    get:
      summary: ユーザー設定取得
      security:
        - bearerAuth: []
    
    put:
      summary: ユーザー設定更新
      security:
        - bearerAuth: []
```

#### データモデル
```typescript
// Bookmark Entity
interface Bookmark {
  id: string;
  userId: string;
  name: string;
  description?: string;
  latitude: number;
  longitude: number;
  category: string;
  tags: string[];
  isPublic: boolean;
  createdAt: Date;
  updatedAt: Date;
}

// UserSettings Entity
interface UserSettings {
  userId: string;
  language: string;
  theme: 'light' | 'dark' | 'auto';
  units: 'metric' | 'imperial';
  defaultMapStyle: string;
  notifications: {
    email: boolean;
    push: boolean;
    marketing: boolean;
  };
  privacy: {
    shareLocation: boolean;
    shareBookmarks: boolean;
    analytics: boolean;
  };
  updatedAt: Date;
}

// SearchHistory Entity
interface SearchHistory {
  id: string;
  userId: string;
  query: string;
  results: SearchResult[];
  timestamp: Date;
  location?: {
    latitude: number;
    longitude: number;
  };
}
```

#### 技術スタック
- **Runtime**: Node.js 20 + TypeScript 5
- **Framework**: Express.js + Prisma
- **Database**: PostgreSQL 15 (ユーザーデータ)
- **Cache**: Redis (設定・セッション)
- **Encryption**: AES-256-GCM (機密データ)
- **Validation**: Joi + class-validator

---

## ☸️ Kubernetes設計

### 🏗️ クラスター構成

#### Namespace設計
```yaml
# システム共通
apiVersion: v1
kind: Namespace
metadata:
  name: kiro-system
  labels:
    name: kiro-system
    tier: system

---
# 各マイクロサービス
apiVersion: v1
kind: Namespace
metadata:
  name: kiro-auth
  labels:
    name: kiro-auth
    tier: application
    service: auth

---
apiVersion: v1
kind: Namespace
metadata:
  name: kiro-map
  labels:
    name: kiro-map
    tier: application
    service: map

---
apiVersion: v1
kind: Namespace
metadata:
  name: kiro-search
  labels:
    name: kiro-search
    tier: application
    service: search

---
apiVersion: v1
kind: Namespace
metadata:
  name: kiro-route
  labels:
    name: kiro-route
    tier: application
    service: route

---
apiVersion: v1
kind: Namespace
metadata:
  name: kiro-user
  labels:
    name: kiro-user
    tier: application
    service: user

---
# 監視・ログ
apiVersion: v1
kind: Namespace
metadata:
  name: kiro-monitoring
  labels:
    name: kiro-monitoring
    tier: monitoring
```

#### リソース制限・要求
```yaml
# 各サービス共通リソース設定
resources:
  requests:
    cpu: 100m
    memory: 128Mi
  limits:
    cpu: 500m
    memory: 512Mi

# サービス別リソース設定
auth-service:
  requests:
    cpu: 100m
    memory: 128Mi
  limits:
    cpu: 500m
    memory: 512Mi

map-service:
  requests:
    cpu: 200m
    memory: 256Mi
  limits:
    cpu: 1000m
    memory: 1Gi

search-service:
  requests:
    cpu: 200m
    memory: 512Mi
  limits:
    cpu: 1000m
    memory: 2Gi

route-service:
  requests:
    cpu: 500m
    memory: 1Gi
  limits:
    cpu: 2000m
    memory: 4Gi

user-service:
  requests:
    cpu: 100m
    memory: 128Mi
  limits:
    cpu: 500m
    memory: 512Mi
```

### 🔄 Deployment設計

#### 認証サービス Deployment
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: auth-service
  namespace: kiro-auth
  labels:
    app: auth-service
    version: v2.1.0
spec:
  replicas: 3
  selector:
    matchLabels:
      app: auth-service
  template:
    metadata:
      labels:
        app: auth-service
        version: v2.1.0
    spec:
      containers:
      - name: auth-service
        image: kiro/auth-service:v2.1.0
        ports:
        - containerPort: 3000
          name: http
        env:
        - name: NODE_ENV
          value: "production"
        - name: PORT
          value: "3000"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: auth-secrets
              key: database-url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: auth-secrets
              key: redis-url
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: auth-secrets
              key: jwt-secret
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
        securityContext:
          runAsNonRoot: true
          runAsUser: 1000
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
      securityContext:
        fsGroup: 1000
```

#### Service設計
```yaml
apiVersion: v1
kind: Service
metadata:
  name: auth-service
  namespace: kiro-auth
  labels:
    app: auth-service
spec:
  selector:
    app: auth-service
  ports:
  - name: http
    port: 80
    targetPort: 3000
    protocol: TCP
  type: ClusterIP
```

#### Ingress設計
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: kiro-ingress
  namespace: kiro-system
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/use-regex: "true"
    nginx.ingress.kubernetes.io/rewrite-target: /$2
spec:
  tls:
  - hosts:
    - api.kiro-map.com
    secretName: kiro-tls
  rules:
  - host: api.kiro-map.com
    http:
      paths:
      - path: /auth(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: auth-service
            port:
              number: 80
      - path: /maps(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: map-service
            port:
              number: 80
      - path: /search(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: search-service
            port:
              number: 80
      - path: /routes(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: route-service
            port:
              number: 80
      - path: /users(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: user-service
            port:
              number: 80
```

### 🔐 ConfigMap・Secret設計

#### ConfigMap
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: auth-config
  namespace: kiro-auth
data:
  NODE_ENV: "production"
  PORT: "3000"
  LOG_LEVEL: "info"
  JWT_EXPIRES_IN: "1h"
  REFRESH_TOKEN_EXPIRES_IN: "7d"
  BCRYPT_ROUNDS: "12"
  RATE_LIMIT_WINDOW: "900000"
  RATE_LIMIT_MAX: "100"
```

#### Secret
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: auth-secrets
  namespace: kiro-auth
type: Opaque
data:
  database-url: <base64-encoded-database-url>
  redis-url: <base64-encoded-redis-url>
  jwt-secret: <base64-encoded-jwt-secret>
  jwt-refresh-secret: <base64-encoded-jwt-refresh-secret>
```

---

## 📊 監視・ログ・トレーシング設計

### 📈 Prometheus監視設計

#### ServiceMonitor設定
```yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: auth-service-monitor
  namespace: kiro-monitoring
  labels:
    app: auth-service
spec:
  selector:
    matchLabels:
      app: auth-service
  endpoints:
  - port: http
    path: /metrics
    interval: 30s
    scrapeTimeout: 10s
```

#### カスタムメトリクス
```typescript
// Prometheus メトリクス定義
import { register, Counter, Histogram, Gauge } from 'prom-client';

// HTTP リクエストメトリクス
const httpRequestsTotal = new Counter({
  name: 'http_requests_total',
  help: 'Total number of HTTP requests',
  labelNames: ['method', 'route', 'status_code', 'service']
});

const httpRequestDuration = new Histogram({
  name: 'http_request_duration_seconds',
  help: 'Duration of HTTP requests in seconds',
  labelNames: ['method', 'route', 'service'],
  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]
});

// 認証メトリクス
const authAttemptsTotal = new Counter({
  name: 'auth_attempts_total',
  help: 'Total number of authentication attempts',
  labelNames: ['type', 'result']
});

const activeSessionsGauge = new Gauge({
  name: 'auth_active_sessions',
  help: 'Number of active user sessions'
});

// データベースメトリクス
const dbConnectionsActive = new Gauge({
  name: 'db_connections_active',
  help: 'Number of active database connections'
});

const dbQueryDuration = new Histogram({
  name: 'db_query_duration_seconds',
  help: 'Duration of database queries in seconds',
  labelNames: ['operation', 'table'],
  buckets: [0.01, 0.05, 0.1, 0.3, 0.5, 1, 3, 5]
});
```

### 📝 構造化ログ設計

#### ログフォーマット
```typescript
// 構造化ログフォーマット
interface LogEntry {
  timestamp: string;
  level: 'debug' | 'info' | 'warn' | 'error';
  service: string;
  version: string;
  traceId?: string;
  spanId?: string;
  userId?: string;
  requestId: string;
  message: string;
  metadata?: Record<string, any>;
  error?: {
    name: string;
    message: string;
    stack: string;
  };
}

// ログ出力例
{
  "timestamp": "2025-08-19T10:30:00.000Z",
  "level": "info",
  "service": "auth-service",
  "version": "v2.1.0",
  "traceId": "1234567890abcdef",
  "spanId": "abcdef1234567890",
  "userId": "user-123",
  "requestId": "req-456",
  "message": "User login successful",
  "metadata": {
    "email": "user@example.com",
    "ip": "192.168.1.100",
    "userAgent": "Mozilla/5.0..."
  }
}
```

#### Fluentd設定
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluentd-config
  namespace: kiro-monitoring
data:
  fluent.conf: |
    <source>
      @type tail
      path /var/log/containers/*kiro*.log
      pos_file /var/log/fluentd-containers.log.pos
      tag kubernetes.*
      format json
      time_key timestamp
      time_format %Y-%m-%dT%H:%M:%S.%NZ
    </source>
    
    <filter kubernetes.**>
      @type kubernetes_metadata
    </filter>
    
    <match kubernetes.**>
      @type elasticsearch
      host elasticsearch.kiro-monitoring.svc.cluster.local
      port 9200
      index_name kiro-logs
      type_name _doc
      include_tag_key true
      tag_key @log_name
      flush_interval 10s
    </match>
```

### 🔍 分散トレーシング設計

#### Jaeger設定
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: jaeger
  namespace: kiro-monitoring
spec:
  replicas: 1
  selector:
    matchLabels:
      app: jaeger
  template:
    metadata:
      labels:
        app: jaeger
    spec:
      containers:
      - name: jaeger
        image: jaegertracing/all-in-one:1.47
        ports:
        - containerPort: 16686
          name: ui
        - containerPort: 14268
          name: collector
        env:
        - name: COLLECTOR_OTLP_ENABLED
          value: "true"
```

#### OpenTelemetry計装
```typescript
// OpenTelemetry設定
import { NodeSDK } from '@opentelemetry/sdk-node';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';
import { JaegerExporter } from '@opentelemetry/exporter-jaeger';

const jaegerExporter = new JaegerExporter({
  endpoint: 'http://jaeger.kiro-monitoring.svc.cluster.local:14268/api/traces',
});

const sdk = new NodeSDK({
  traceExporter: jaegerExporter,
  instrumentations: [getNodeAutoInstrumentations()],
  serviceName: 'auth-service',
  serviceVersion: 'v2.1.0',
});

sdk.start();

// カスタムスパン作成
import { trace } from '@opentelemetry/api';

const tracer = trace.getTracer('auth-service', 'v2.1.0');

async function authenticateUser(email: string, password: string) {
  const span = tracer.startSpan('authenticate_user');
  
  try {
    span.setAttributes({
      'user.email': email,
      'auth.method': 'password'
    });
    
    // 認証処理
    const user = await userService.findByEmail(email);
    const isValid = await bcrypt.compare(password, user.passwordHash);
    
    span.setAttributes({
      'auth.success': isValid,
      'user.id': user.id
    });
    
    return isValid ? user : null;
  } catch (error) {
    span.recordException(error);
    span.setStatus({ code: SpanStatusCode.ERROR });
    throw error;
  } finally {
    span.end();
  }
}
```

---

## 🔒 セキュリティ設計

### 🛡️ サービス間セキュリティ

#### mTLS (Mutual TLS)設定
```yaml
# Istio ServiceMesh設定
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: kiro-system
spec:
  mtls:
    mode: STRICT

---
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: auth-service-policy
  namespace: kiro-auth
spec:
  selector:
    matchLabels:
      app: auth-service
  rules:
  - from:
    - source:
        principals: ["cluster.local/ns/kiro-system/sa/api-gateway"]
  - to:
    - operation:
        methods: ["GET", "POST"]
        paths: ["/auth/*"]
```

#### API Gateway セキュリティ
```typescript
// API Gateway セキュリティミドルウェア
import rateLimit from 'express-rate-limit';
import helmet from 'helmet';
import cors from 'cors';

// レート制限
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15分
  max: 100, // リクエスト数制限
  message: 'Too many requests from this IP',
  standardHeaders: true,
  legacyHeaders: false,
  store: new RedisStore({
    client: redisClient,
    prefix: 'rl:'
  })
});

// セキュリティヘッダー
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", "https://api.kiro-map.com"]
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
}));

// CORS設定
app.use(cors({
  origin: process.env.ALLOWED_ORIGINS?.split(',') || ['https://kiro-map.com'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
}));

// JWT検証ミドルウェア
const verifyToken = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');
    if (!token) {
      return res.status(401).json({ error: 'No token provided' });
    }
    
    const decoded = jwt.verify(token, process.env.JWT_SECRET!);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid token' });
  }
};
```

### 🔐 Secret管理

#### External Secrets Operator
```yaml
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: vault-backend
  namespace: kiro-system
spec:
  provider:
    vault:
      server: "https://vault.kiro-system.svc.cluster.local:8200"
      path: "secret"
      version: "v2"
      auth:
        kubernetes:
          mountPath: "kubernetes"
          role: "kiro-role"

---
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: auth-secrets
  namespace: kiro-auth
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: vault-backend
    kind: SecretStore
  target:
    name: auth-secrets
    creationPolicy: Owner
  data:
  - secretKey: database-url
    remoteRef:
      key: auth-service
      property: database-url
  - secretKey: jwt-secret
    remoteRef:
      key: auth-service
      property: jwt-secret
```

---

## 🚀 CI/CDパイプライン設計

### 🔄 GitHub Actions ワークフロー

#### Pull Request ワークフロー
```yaml
name: PR Validation
on:
  pull_request:
    branches: [main, develop]

jobs:
  lint-and-test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [auth, map, search, route, user]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        cache-dependency-path: 'services/${{ matrix.service }}/package-lock.json'
    
    - name: Install dependencies
      run: |
        cd services/${{ matrix.service }}
        npm ci
    
    - name: Lint
      run: |
        cd services/${{ matrix.service }}
        npm run lint
    
    - name: Type check
      run: |
        cd services/${{ matrix.service }}
        npm run type-check
    
    - name: Unit tests
      run: |
        cd services/${{ matrix.service }}
        npm run test:unit
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: services/${{ matrix.service }}/coverage/lcov.info
        flags: ${{ matrix.service }}

  integration-test:
    runs-on: ubuntu-latest
    needs: lint-and-test
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run integration tests
      run: npm run test:integration
      env:
        DATABASE_URL: postgresql://postgres:test@localhost:5432/test
        REDIS_URL: redis://localhost:6379

  security-scan:
    runs-on: ubuntu-latest
    needs: lint-and-test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Run Snyk security scan
      uses: snyk/actions/node@master
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
    
    - name: Run OWASP ZAP scan
      uses: zaproxy/action-baseline@v0.7.0
      with:
        target: 'http://localhost:3000'
```

#### Main Branch デプロイワークフロー
```yaml
name: Deploy to Production
on:
  push:
    branches: [main]

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [auth, map, search, route, user]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Login to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: services/${{ matrix.service }}
        push: true
        tags: |
          ghcr.io/${{ github.repository }}/${{ matrix.service }}:latest
          ghcr.io/${{ github.repository }}/${{ matrix.service }}:${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy-staging:
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: staging
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
    
    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: 'v3.12.0'
    
    - name: Deploy to staging
      run: |
        helm upgrade --install kiro-staging ./helm/kiro \
          --namespace kiro-staging \
          --create-namespace \
          --set image.tag=${{ github.sha }} \
          --set environment=staging \
          --wait --timeout=10m

  e2e-test:
    runs-on: ubuntu-latest
    needs: deploy-staging
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
    
    - name: Install Playwright
      run: |
        npm ci
        npx playwright install
    
    - name: Run E2E tests
      run: npm run test:e2e
      env:
        BASE_URL: https://staging.kiro-map.com

  deploy-production:
    runs-on: ubuntu-latest
    needs: e2e-test
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
    
    - name: Setup Helm
      uses: azure/setup-helm@v3
    
    - name: Deploy to production
      run: |
        helm upgrade --install kiro-production ./helm/kiro \
          --namespace kiro-production \
          --create-namespace \
          --set image.tag=${{ github.sha }} \
          --set environment=production \
          --wait --timeout=15m
    
    - name: Post-deploy verification
      run: |
        kubectl rollout status deployment/auth-service -n kiro-auth
        kubectl rollout status deployment/map-service -n kiro-map
        kubectl rollout status deployment/search-service -n kiro-search
        kubectl rollout status deployment/route-service -n kiro-route
        kubectl rollout status deployment/user-service -n kiro-user
```

---

## 📈 パフォーマンス・スケーリング設計

### 🎯 オートスケーリング設定

#### Horizontal Pod Autoscaler
```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: auth-service-hpa
  namespace: kiro-auth
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: auth-service
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 10
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
```

#### Vertical Pod Autoscaler
```yaml
apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: auth-service-vpa
  namespace: kiro-auth
spec:
  targetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: auth-service
  updatePolicy:
    updateMode: "Auto"
  resourcePolicy:
    containerPolicies:
    - containerName: auth-service
      maxAllowed:
        cpu: 1
        memory: 1Gi
      minAllowed:
        cpu: 100m
        memory: 128Mi
```

### 🚀 キャッシュ戦略

#### Redis Cluster設定
```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: redis-cluster
  namespace: kiro-system
spec:
  serviceName: redis-cluster
  replicas: 6
  selector:
    matchLabels:
      app: redis-cluster
  template:
    metadata:
      labels:
        app: redis-cluster
    spec:
      containers:
      - name: redis
        image: redis:7-alpine
        ports:
        - containerPort: 6379
          name: client
        - containerPort: 16379
          name: gossip
        command:
        - redis-server
        - /etc/redis/redis.conf
        - --cluster-enabled
        - "yes"
        - --cluster-config-file
        - /data/nodes.conf
        - --cluster-node-timeout
        - "5000"
        - --appendonly
        - "yes"
        volumeMounts:
        - name: data
          mountPath: /data
        - name: config
          mountPath: /etc/redis
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 10Gi
```

#### CDN統合
```typescript
// CDN統合設定
interface CDNConfig {
  provider: 'cloudflare' | 'aws' | 'gcp';
  zones: {
    tiles: string;
    static: string;
    api: string;
  };
  caching: {
    tiles: {
      ttl: '7d';
      edgeCache: true;
      browserCache: '1d';
    };
    static: {
      ttl: '30d';
      edgeCache: true;
      browserCache: '7d';
    };
    api: {
      ttl: '5m';
      edgeCache: false;
      browserCache: '0';
    };
  };
}

// CDNサービス実装
class CDNService {
  async purgeCache(paths: string[]): Promise<void> {
    // CDN キャッシュパージ実装
  }
  
  async getEdgeLocations(): Promise<EdgeLocation[]> {
    // エッジロケーション取得
  }
  
  async getCacheStats(): Promise<CacheStats> {
    // キャッシュ統計取得
  }
}
```

---

**アーキテクチャ設計書作成日**: 2025年8月19日  
**作成者**: Kiro AI Assistant  
**レビュー者**: システムアーキテクト  
**承認者**: CTO  
**次回レビュー**: 2025年8月26日  
**バージョン**: 1.0